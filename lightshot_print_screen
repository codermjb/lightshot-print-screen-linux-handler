#!/bin/sh

#―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――#
#                    Lightshot print screen Linux handler                     #
#                         Portable POSIX shell script                         #
#                    Copyright: 2018-2020 Vlastimil Burian                    #
#                       E-mail: info@vlastimilburian.cz                       #
#                              License: GPL v3.0                              #
#                                Revision: 2.9                                #
#                        GitHub: https://git.io/fx2US                         #
#―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――#

# global shell script variables
# hotkey variable for easy set-up; overridable with -k switch
# set this to the same hotkey which you have set up in your Lightshot options
# for the left control key and the print screen key put Control_L+Print in
hotkey=Print

# global shell script options
# treat unset variables as an error when substituting
# clarification: this means that accessing so far undeclared variable
# produces immediate termination of the script with line number
# and message: "unbound variable" or "parameter not set"
set -o nounset

tput_colors_supported ()
# bool function - getter of the terminal color support
{
    command -v tput && tput bold && tput setaf 1 && [ "$(tput colors)" -ge 8 ]
} > /dev/null 2>&1

if tput_colors_supported; then
    # shellcheck disable=SC2034
    color_reset=$(tput sgr0)
    # shellcheck disable=SC2034
    bold_text=$(tput bold)
    # shellcheck disable=SC2034
    color_red=$bold_text$(tput setaf 1)
    # shellcheck disable=SC2034
    color_green=$bold_text$(tput setaf 2)
    # shellcheck disable=SC2034
    color_yellow=$bold_text$(tput setaf 3)
    # shellcheck disable=SC2034
    color_blue=$bold_text$(tput setaf 4)
    # shellcheck disable=SC2034
    color_magenta=$bold_text$(tput setaf 5)
    # shellcheck disable=SC2034
    color_cyan=$bold_text$(tput setaf 6)
    # shellcheck disable=SC2034
    color_white=$bold_text$(tput setaf 7)
else
    # shellcheck disable=SC2034
    color_reset=
    # shellcheck disable=SC2034
    bold_text=
    # shellcheck disable=SC2034
    color_red=
    # shellcheck disable=SC2034
    color_green=
    # shellcheck disable=SC2034
    color_yellow=
    # shellcheck disable=SC2034
    color_blue=
    # shellcheck disable=SC2034
    color_cyan=
    # shellcheck disable=SC2034
    color_white=
fi

dump_arguments ()
# string function - prints arguments; position and contents
# indicates empty arguments and integer numbers for debugging
{
    printf '%b' "dump_arguments()\\n----------------\\n$# arguments are being inspected"
    [ $# -gt 0 ] && { printf ':\n'; i=1; } || printf '.\n'
    while [ $# -gt 0 ]; do
        printf '%s' "[$i]: '$1'"
        [ -z "$1" ] && printf ' (empty)'
        [ "$1" -eq "$1" ] 2> /dev/null && printf ' (integer)'
        printf '\n'
        shift 1
        i=$((i+1))
    done
} >&2

print_error ()
# string function - prints an error message with a custom heading
{
    if ! { [ $# -eq 2 ] && [ -n "$1" ] && [ -n "$2" ]; }; then
        dump_arguments "$@"
        # shellcheck disable=SC2016
        printf '%b\n' \
            '\nprint_error() input check' \
            'Wrong number or empty arguments have been passed to the function.' \
            'Expected the following strings: $1 = error heading, $2 = error message.'
        exit 1
    fi
    printf '%b\n' \
        "${color_red}Error occurred$color_reset" \
        "Error heading: $color_yellow$1$color_reset" \
        "Error message: $2"
        
} >&2

print_error__exit ()
# direcly uses print_error, but this one exits the script
{
    if ! { [ $# -eq 2 ] && [ -n "$1" ] && [ -n "$2" ]; } &&
       ! { [ $# -eq 3 ] && [ -n "$1" ] && [ -n "$2" ] && [ -n "$3" ] && [ "$3" -eq "$3" ] 2> /dev/null; }; then
        dump_arguments "$@"
        # shellcheck disable=SC2016
        printf '%b\n' \
            '\nprint_error__exit() input check' \
            'Wrong number, type or empty arguments have been passed to the function.' \
            'Expected the following strings: $1 = error heading, $2 = error message.' \
            'Optionally, accepting a number: $3 = exit code; if not given 1 is used.'
        exit 1
    fi
    [ $# -eq 3 ] && exit_code=$3 || exit_code=1
    print_error "$1" "$2"
    exit "$exit_code"
} >&2

check_for_requirements ()
# void function - finds out if all required programs are available
{
    if [ $# -eq 0 ]; then
        print_error__exit 'check_for_requirements() input check' "No arguments passed to the function! At least one program name expected."
    fi
    while [ $# -gt 0 ]; do
        if [ -z "$1" ]; then
            print_error__exit 'check_for_requirements() input check' "Empty argument passed to the function!"
        fi
        if ! command -v "$1" > /dev/null 2>&1; then
            print_error__exit 'check_for_requirements()' "This script requires '$1' but it is not available on this system! Please install the corresponding package manually."
        fi
        shift 1
    done
}

check_for_requirements xdotool pgrep

is_integer ()
# bool function - finds out if a given argument is an integer number
{
    if [ $# -ne 1 ]; then
        dump_arguments "$@"
        print_error__exit 'is_integer() input check' "Exactly one argument was not passed to the function! One variable or literal to test expected."
    fi
    [ "$1" -eq "$1" ] 2> /dev/null
}

print_usage_and_exit ()
# prints out usage help and exits the script
{
    if [ $# -ne 1 ] || ! is_integer "$1"; then
        dump_arguments "$@"
        print_error__exit 'print_usage_and_exit() input check' "Exactly one argument as a number was not passed to the function! Expected an exit code from the script."
    fi
    [ "$1" -ne 0 ] && exec >&2

cat << EOF
Script  : Lightshot print screen Linux handler
Version : 2.9
GitHub  : https://git.io/fx2US
-------------------------------------------------------------------
Description: This script works with XDOTOOL to trigger Print Screen
key combination in Lightshot application installed on Linux in Wine
-------------------------------------------------------------------
Usage: ./$(basename "$0") [-k "HotKey"]

    -k "HotKey": Optional switch requiring one argument,
        which is the print screen hotkey combination.
        For the left Control key and the Print Screen key
        that would be "Control_L+Print" (as an example).

    -h: Show this help.
EOF

    exit "$1"
}

while getopts ":hk:" cli_option; do
    case "$cli_option" in
        (k) hotkey=$OPTARG        ; break ;;
        (h) print_usage_and_exit 0; break ;;
        (*) print_usage_and_exit 1; break ;;
    esac
done
shift $((OPTIND - 1))

get_process_id ()
# tries to find out a process id using a process name
{
    # check if exactly one argument has been passed
    if [ $# -ne 1 ]; then
        dump_arguments "$@"
        print_error__exit 'get_process_id() input check' "Exactly one argument was not passed to the function!"
    fi

    # check if the argument is an empty string
    if [ -z "$1" ]; then
        print_error__exit 'get_process_id() input check' "The argument is an empty string! Expected a process name."
    fi

    # try to get the process id using the process name
    pgrep "$1" | head -1
}

get_window_id ()
# tries to find out a window id using a process id and a window name
{
    if [ $# -ne 2 ]; then
        dump_arguments "$@"
        print_error__exit 'get_window_id() input check' "Exactly two arguments have not been passed to the function! Expected a process id and a window name."
    fi

    # check if the first argument is a number
    if ! is_integer "$1"; then
        dump_arguments "$@"
        print_error__exit 'get_window_id() input check' "The first argument is not a number! Expected a process id."
    fi

    # check if the second argument is an empty string
    if [ -z "$2" ]; then
        print_error__exit 'get_window_id() input check' "The second argument is an empty string! Expected a window name."
    fi

    #--all  : Require all conditions to be met.
    #--limit: Stop searching after finding N matching windows.
    #--pid  : Match windows that belong to a specific process id.
    #--name : Match against the window name. This is the same string that is displayed in the window titlebar.
    if ! xdotool search --all --limit 1 --pid "$1" --name "$2"; then
        print_error__exit 'get_window_id()' "No window matching process id '$1' and window name '$2' has been found."
    fi
}

# try to get the Lightshot process id
lightshot_process_id=$(get_process_id Lightshot.exe)

if ! is_integer "$lightshot_process_id"; then
    # shellcheck disable=SC2016
    print_error__exit 'is_integer $lightshot_process_id' "Lightshot process is not running."
fi

# try to get the Lightshot window id
lightshot_window_id=$(get_window_id "$lightshot_process_id" Lightshot)

if ! is_integer "$lightshot_window_id"; then
    # shellcheck disable=SC2016
    print_error__exit 'is_integer $lightshot_window_id' "Lightshot process is running but window not found."
fi

# simulate the pre-defined print screen hotkey on the Lightshot window
xdotool key --window "$lightshot_window_id" "$hotkey"
